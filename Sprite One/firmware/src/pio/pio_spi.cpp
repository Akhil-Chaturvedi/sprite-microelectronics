// ==============================================================================
// Sprite One - PIO SPI Implementation
// ==============================================================================

#include "pio_spi.h"
#include "spi_slave.pio.h" // Generated by pioasm

PioSpi* PioSpi::instance = nullptr;

PioSpi::PioSpi() : rx_count(0), tx_count(0), error_count(0) {
    rx_buffer.write_pos = 0;
    rx_buffer.read_pos = 0;
    instance = this;
}

bool PioSpi::begin() {
    // Load PIO program
    uint offset = pio_add_program(SPI_PIO, &spi_slave_rx_program);
    
    // Configure state machine
    pio_sm_config c = spi_slave_rx_program_get_default_config(offset);
    
    // Configure pins
    pio_gpio_init(SPI_PIO, SPI_MOSI_PIN);
    pio_gpio_init(SPI_PIO, SPI_MISO_PIN);
    
    // MOSI is input
    pio_sm_set_consecutive_pindirs(SPI_PIO, SPI_SM, SPI_MOSI_PIN, 1, false);
    
    // MISO is output
    pio_sm_set_consecutive_pindirs(SPI_PIO, SPI_SM, SPI_MISO_PIN, 1, true);
    
    // Configure IN pins (MOSI for sampling)
    sm_config_set_in_pins(&c, SPI_MOSI_PIN);
    
    // Configure OUT pins (MISO for output)
    sm_config_set_out_pins(&c, SPI_MISO_PIN, 1);
    
    // Shift config: LSB first, autopush at 8 bits
    sm_config_set_in_shift(&c, false, true, 8);
    sm_config_set_out_shift(&c, false, true, 8);
    
    // Run at full speed (125 MHz sysclk / 1.0 = 125 MHz)
    // PIO will sample at half rate = 62.5 MHz max SPI clock
    sm_config_set_clkdiv(&c, 1.0);
    
    // Initialize state machine
    pio_sm_init(SPI_PIO, SPI_SM, offset, &c);
    
    // Set up interrupt
    pio_set_irq0_source_enabled(SPI_PIO, pis_interrupt0, true);
    irq_set_exclusive_handler(PIO0_IRQ_0, irqHandler);
    irq_set_enabled(PIO0_IRQ_0, true);
    
    // Start state machine
    pio_sm_set_enabled(SPI_PIO, SPI_SM, true);
    
    Serial.println("[PIO_SPI] Initialized successfully");
    Serial.print("[PIO_SPI] Max SPI clock: 62.5 MHz");
    
    return true;
}

// IRQ handler - called when PIO receives a byte
void PioSpi::irqHandler() {
    if (instance == nullptr) return;
    
    // Clear the IRQ flag
    pio_interrupt_clear(SPI_PIO, 0);
    
    // Check if data is available in RX FIFO
    if (!pio_sm_is_rx_fifo_empty(SPI_PIO, SPI_SM)) {
        uint8_t byte = (uint8_t)pio_sm_get(SPI_PIO, SPI_SM);
        instance->bufferPush(byte);
        instance->rx_count++;
    }
}

void PioSpi::bufferPush(uint8_t byte) {
    uint16_t next_pos = (rx_buffer.write_pos + 1) % RX_BUFFER_SIZE;
    
    // Check for overflow
    if (next_pos == rx_buffer.read_pos) {
        error_count++;
        return; // Buffer full, drop byte
    }
    
    rx_buffer.data[rx_buffer.write_pos] = byte;
    rx_buffer.write_pos = next_pos;
}

bool PioSpi::bufferPop(uint8_t* byte) {
    if (rx_buffer.read_pos == rx_buffer.write_pos) {
        return false; // Buffer empty
    }
    
    *byte = rx_buffer.data[rx_buffer.read_pos];
    rx_buffer.read_pos = (rx_buffer.read_pos + 1) % RX_BUFFER_SIZE;
    return true;
}

bool PioSpi::available() {
    return rx_buffer.read_pos != rx_buffer.write_pos;
}

uint16_t PioSpi::bytesAvailable() {
    if (rx_buffer.write_pos >= rx_buffer.read_pos) {
        return rx_buffer.write_pos - rx_buffer.read_pos;
    } else {
        return RX_BUFFER_SIZE - rx_buffer.read_pos + rx_buffer.write_pos;
    }
}

uint8_t PioSpi::read() {
    uint8_t byte;
    while (!bufferPop(&byte)) {
        tight_loop_contents(); // Wait
    }
    return byte;
}

uint16_t PioSpi::read(uint8_t* buffer, uint16_t length) {
    uint16_t count = 0;
    while (count < length && bufferPop(&buffer[count])) {
        count++;
    }
    return count;
}

void PioSpi::write(uint8_t data) {
    // Wait if TX FIFO is full
    while (pio_sm_is_tx_fifo_full(SPI_PIO, SPI_SM)) {
        tight_loop_contents();
    }
    
    pio_sm_put(SPI_PIO, SPI_SM, data);
    tx_count++;
}

void PioSpi::write(const uint8_t* buffer, uint16_t length) {
    for (uint16_t i = 0; i < length; i++) {
        write(buffer[i]);
    }
}

void PioSpi::flush() {
    rx_buffer.read_pos = rx_buffer.write_pos;
}
